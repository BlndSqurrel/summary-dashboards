<!DOCTYPE html>
<html>
<head>
    <title>pyramid-success-chart</title>

    <script type="text/javascript" src="/apps/2.0rc2/sdk.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/async/1.22/async.min.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/highcharts.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/modules/funnel.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
Ext.define("RallyFunctions", function() {

    var self;

    return {
        config : {
            ctx : {}
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            return this;
        },

        _wsapiQuery : function( config , callback ) {

            var storeConfig = {
                autoLoad : true,
                limit : "Infinity",
                model : config.model,
                fetch : config.fetch,
                filters : config.filters,
                listeners : {
                    scope : this,
                    load : function(store, data) {
                        callback(null,data);
                    }
                }
            };
            if (!_.isUndefined(config.context)) {
                storeConfig.context = config.context;
            }         
            Ext.create('Rally.data.WsapiDataStore', storeConfig);
        },

        // create a filter based on a combination of release and/or iteration
        createFilter : function( releaseName, iterationName ) { 
            var filter = null;

            if (!_.isNull(releaseName)) {
                filter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Release.Name',
                    operator: '=',
                    value: releaseName
                });
            }

            if (!_.isNull(iterationName)) {
                var ifilter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Iteration.Name',
                    operator: '=',
                    value: iterationName
                });

                filter = _.isNull(filter) ? ifilter : filter.and(ifilter);              
            }
            return filter;
        },

        createFeatureFilter : function( releaseName ) { 
            var filter = null;

            if (!_.isNull(releaseName)) {
                filter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Release.Name',
                    operator: '=',
                    value: releaseName
                });
            }

            return filter;
        },

        subscribe : function(app) {
            app.subscribe(app, 'timeboxReleaseChanged', app._timeboxChanged, app);
            app.subscribe(app, 'timeboxIterationChanged', app._timeboxChanged, app);
        }
       
    };
   
});
                /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
Ext.define("ProjectStories", function() {

    var self;

    return {
        config : {
            ctx : {},
            filter : null,
            featureFilter : null
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            return this;
        },

        readProjectStories : function(callback) {
            var fns = [
                self.readStates.bind(self),
                self.readProjects.bind(self),
                self.getReportProjects.bind(self),
                self.readStories.bind(self)
            ];

            if (self.featureFilter!==null) {
                fns = [
                    self.readStates.bind(self),
                    self.readFeatureTypes.bind(self),
                    self.readProjects.bind(self),
                    self.getReportProjects.bind(self),
                    self.readStories.bind(self),
                    self.readFeatures.bind(self)
                ];
            }

            async.waterfall( fns , function(err,result) {
                callback( null, self.stories, self.reportProjects, self.scheduleStates,self.features );
            });
        },

        readStates : function(callback) {
            var that = this;
            Rally.data.ModelFactory.getModel({
                type: 'UserStory',
                success: function(model) {
                    model.getField('ScheduleState').getAllowedValueStore().load({
                        callback: function(records, operation, success) {
                            self.scheduleStates = _.map(records,function(r){ return r.get("StringValue");});
                            callback(null);
                        }
                    });
                }
            });
        },

        readFeatureTypes : function(callback) {

            var that = this;

            var configs = [{ model : "TypeDefinition",
                fetch : true,
                filters : [ { property:"Ordinal", operator:"=", value:0} ]
            }];

            async.map(configs,self._wsapiQuery,function(err,results) {
                self.featureType = _.first(_.first(results)).get("TypePath");
                callback(null);
            });

        },

        readProjects : function(callback) {
            var that = this;
            var config = { model : "Project", fetch : true, filters : [] };
            self._wsapiQuery( config, callback );
        },    

        // child projects are what we graph
        getReportProjects : function(projects,callback) {

           self.projects = projects;

            // filter to projects which are child of the current context project
            self.reportProjects = _.filter(projects, function(project) {
                return self._isChildOf( project, self.ctx.getProject() );
            });

            // if no children add self
            if (self.reportProjects.length ===0) {
                self.reportProjects.push(_.find(self.projects,function(project) {
                    return project.get("ObjectID") === self.ctx.getProject().ObjectID;
                }));
            }

            callback(null);
        },

        readStories : function(callback) {

            var configs = _.map(self.reportProjects,function(project) {
                return {
                    model : "HierarchicalRequirement",
                    filters : [self.filter],
                    fetch : ["ObjectID","ScheduleState","PlanEstimate","Project"],
                    context : {
                        project: project.get("_ref"),
                        projectScopeUp: false,
                        projectScopeDown: true
                    }
                };
            });

            // read stories for each reporting project
            async.map(configs,self._wsapiQuery,function(error,results) {
                self.stories = results;
                callback(null);
            });
        },

        readFeatures : function(callback) {

            var configs = _.map(self.reportProjects,function(project) {
                return {
                    model : self.featureType,
                    filters : [self.featureFilter],
                    fetch : ["FormattedID","Name","ObjectID","LeafStoryCount","LeafStoryPlanEstimateTotal",
                        "PreliminaryEstimate", "AcceptedLeafStoryCount", "AcceptedLeafStoryPlanEstimateTotal",
                        "PercentDoneByStoryCount","c_ValueMetricKPI","Rank"],
                    order : [ { property : 'DragAndDropRank', direction : 'ASC' } ],
                    context : {
                        project: project.get("_ref"),
                        projectScopeUp: false,
                        projectScopeDown: true
                    }
                };
            });

            // read stories for each reporting project
            async.map(configs,self._wsapiQuery,function(error,results) {
                self.features = results;
                callback(null);
            });
        },

        _wsapiQuery : function( config , callback ) {

            var storeConfig = {
                autoLoad : true,
                limit : "Infinity",
                model : config.model,
                fetch : config.fetch,
                filters : config.filters,
                listeners : {
                    scope : this,
                    load : function(store, data) {
                        callback(null,data);
                    }
                }
            };

            if (!_.isUndefined(config.context)) {
                storeConfig.context = config.context;
            }
            if (!_.isUndefined(config.order)) {
                storeConfig.order = config.order;
            }

            Ext.create('Rally.data.WsapiDataStore', storeConfig);
        },

        _isChildOf : function( child, parent ) {
            var childParentRef = !_.isNull(child.get("Parent")) ? child.get("Parent")._ref : "null";
            return parent._ref.indexOf( childParentRef ) > -1;
        }
        
    };
   
});
                Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    config: {
        defaultSettings : { features : true }
    },

    getSettingsFields: function() {
        return [
            { name: 'features', xtype: 'rallycheckboxfield', label : '% based on features (otherwise stories)' }
        ];
    }, 

    launch: function() {
        var that = this;
        var release = 'Release 1';
        var iteration = null; // "Iteration 1"; // this.getTimeboxScope();
        console.log(that.getSetting('features'));
        that.rallyFunctions = Ext.create("RallyFunctions");
        that.rallyFunctions.subscribe(that);
        
        var tbs = that.getTimeboxScope();

        if (!_.isNull(tbs)) {
            release = tbs.type === "release" ? tbs.name : null;
            iteration = tbs.type === "iteration" ? tbs.name : null;
        }

        that.run(release,iteration, that.getSetting('features')===true);
    },

    run : function(releaseName,iterationName,chartFeatures) {

        console.log("features",chartFeatures===true);

        var that = this;

        var pr = Ext.create( "ProjectStories", {
            ctx : that.getContext(),
            filter : that.rallyFunctions.createFilter(releaseName, iterationName),
            featureFilter : that.rallyFunctions.createFeatureFilter(releaseName)
        });

        pr.readProjectStories(function(error, stories, projects, states,features){
            if (chartFeatures===true) {
                that.prepareFeatureChartData( features, projects, function(error,series,categories) {
                    that.createChart(series,categories);    
                });              
            } else {
                that.prepareChartData( stories, projects, states, function(error,series,categories) {
                    that.createChart(series,categories);    
                });
            }           
        });
    },

    _timeboxChanged : function(timebox) {
        var that = this;
        console.log("Pyramid Chart:_timeboxChanged received");
        if (timebox.get("_type")==='release') {
            that.releaseName = timebox.get("Name");
            that.run(that.releaseName,null);
        } else
            that.run(null,timebox.get("Name"));
    },


    getTimeboxScope : function() {
        var timeboxScope = this.getContext().getTimeboxScope();
        if (timeboxScope) {
            return { type : timeboxScope.getType(), name : timeboxScope.getRecord().get("Name") };
        }
        return null;
    },

    onTimeboxScopeChange: function(newTimeboxScope) {
        
        this.callParent(arguments);
        if ((newTimeboxScope) && (newTimeboxScope.getType() === 'iteration')) {
            this.run(null,newTimeboxScope.getRecord().get("Name"));
        } else {
            if ((newTimeboxScope) && (newTimeboxScope.getType() === 'release')) {
                this.run(newTimeboxScope.getRecord().get("Name"),null);
            }
        }
    },

    prepareChartData : function(stories, projects, states, callback) {

        var that = this;
        var categories = _.map( projects, function(p) { return p.get("Name"); });
        var completedStates = ["Accepted",_.last(states)];

        var pointsValue = function(value) {
            return !_.isUndefined(value) && !_.isNull(value) ? value : 0;
        };

        // totals points for a set of work items based on if they are in a set of states
        var summarize = function( workItems, states ) {
            var stateTotal = _.reduce(  workItems, function(memo,workItem) {
                    return memo + ( _.indexOf(states,workItem.get("ScheduleState")) > -1 ? 
                            pointsValue(workItem.get("PlanEstimate")) : 0);
                },0);
            return stateTotal;
        };

        var data = _.map(categories,function(project,index){
            return [ project, 
                summarize(stories[index],states),
                summarize(stories[index],completedStates)
            ];
        });
        var sortedData = data.sort(function(a,b) { return b[1] - a[1]; });

        var seriesData = [{
            name : 'Project Scope',
            data : sortedData,
            completedData : _.map(sortedData,function(d) { return d[2];})
        }];

        callback(null,categories,seriesData);

    },

    prepareFeatureChartData : function(features, projects, callback) {

        var that = this;
        var categories = _.map( projects, function(p) { return p.get("Name"); });
    
        var pointsValue = function(value) {
            return !_.isUndefined(value) && !_.isNull(value) ? value : 0;
        };

        // totals points for a set of work items based on if they are in a set of states
        var summarize = function( workItems, completed ) {

            if (completed===false)
                return workItems.length;
            else { 
                return _.reduce(  workItems, function(memo,workItem) {
                    return memo + ( workItem.get("PercentDoneByStoryCount") >= 1 ? 1 : 0);
                },0);
            }
        };

        var data = _.map(categories,function(project,index){
            console.log(project,features[index]);
            return [ project, 
                summarize(features[index],false),
                summarize(features[index],true),
                _.map(features[index],function(feature){ return feature.get("Name") /* ("c_ValueMetricKPI") */; })
            ];
        });
        var sortedData = data.sort(function(a,b) { return b[1] - a[1]; });

        var seriesData = [{
            name : 'Project Scope',
            data : sortedData,
            completedData : _.map(sortedData,function(d) { return d[2];}),
            featureWords : _.map(sortedData,function(d) { return d[3];})
        }];

        console.log(categories,seriesData);

        callback(null,categories,seriesData);
    },


    createChart : function(categories,seriesData,callback) {

        var isEmpty = function(series) {
            var total = _.reduce(_.first(series).data,function(memo,d) { 
                return memo + d[1];
            },0);
            return total === 0;
        };

        var that = this;

        // draws the 'words' on the pyramid chart
        var load = function() {

            var ren = this.renderer;
            var wordHeight = 11;
            var series = _.first(this.series);
            console.log("series",series);

            _.each(series.points,function(point,index) {
                var featureWords = series.options.featureWords[index].slice(0,4);
                var y = point.plotY - (( featureWords.length * wordHeight)/2);
                // console.log("point", point.plotY, index, this.series.options.featureWords );
                // ren.path(['M', 0, point.plotY,'L',100,point.plotY])
                // .attr({
                //     'stroke-width': 1,
                //     stroke: 'silver',
                //     dashstyle: 'dot'
                // })
                // .add();
                _.each(featureWords,function(fw,x) {
                    var word = fw.split(' ').slice(0,2).join(' ');
                    ren.label(word, 5, y + (x*wordHeight))
                    .css({
                        fontWeight: 'normal',
                        fontSize: '75%'
                    })
                    .add();
                });
            });

            ren.label("Only first 3 features are shown", 5, 285)
            .css({
                fontWeight: 'normal',
                fontSize: '60%'
            })
            .add();

            // Separator, client from service
            // ren.path(['M', 120, 40, 'L', 120, 330])
            //     .attr({
            //         'stroke-width': 2,
            //         stroke: 'silver',
            //         dashstyle: 'dash'
            //     })
            //     .add();
            // // Headers
            // ren.label('Web client', 20, 40)
            //     .css({
            //         fontWeight: 'bold'
            //     })
            //     .add();
        };

        var chartConfig = {
            colors : ["#3498db","#f1c40f","#c0392b","#9b59b6","#2ecc71"],
             chart: {
                type: 'pyramid',
                marginRight : 100,
                events : {
                    load : load
                }
            },
            title: {
                text: ''
            },
            plotOptions: {
                pyramid : {
                    allowPointSelect : true
                },
                series: {
                    dataLabels: {
                        enabled: true,
                        formatter : function() {
                            var scope = this.point.y;
                            var completed = this.point.series.options.completedData[this.point.index];
                            var pct = Math.round( scope > 0 ? (completed/scope)*100 : 0);
                            return " [" + completed + "/" + scope + "] ("+pct+"%) " + 
                                _.last(this.point.name.split(">"));
                        },
                        softConnector: true,
                        distance : 10
                    }
                }
            },
            legend : {
                enabled : false
            },
            series: seriesData
        };

        if (!_.isUndefined(that.x)) {
            that.remove(that.x);
        }

        that.x = Ext.widget('container',{
            autoShow: true ,shadow: false,title: "",resizable: false,margin: 10,
            html: '<div id="chart-container" class="chart-container"></div>',
            listeners: {
                resize: function(panel) {
                },
                afterrender : function(panel) {
                    $('#chart-container').highcharts(chartConfig);
                }
            }
        });

        if (!isEmpty(seriesData))
            that.add(that.x);
    }

});


            Rally.launchApp('CustomApp', {
                name:"pyramid-success-chart",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}
.chart-container {
  width: 500px;
  height: 300px;
}

    </style>
</head>
<body>
</body>
</html>
