<!DOCTYPE html>
<html>
<head>
    <title>Work Item Field Issues</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Jun 04 2015 23:37:04 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Jun 04 2015 23:37:04 GMT-0600 (MDT)";
        var CHECKSUM = 9255609971;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.ValidationRules',{

    ruleFnPrefix: 'ruleFn_',
    requiredFields: undefined,

    constructor: function(config){
        Ext.apply(this, config);
    },

    getRules: function(){
        var ruleFns = [],
            ruleRe = new RegExp('^' + this.ruleFnPrefix);

        for (var fn in this)
        {
            if (ruleRe.test(fn)){
                ruleFns.push(fn);
            }
        }
        return ruleFns;
    },
    ruleFn_missingFields: function(r) {
        var missingFields = [];

        _.each(this.requiredFields, function (f) {
            if (!r.get(f)) {
                missingFields.push(f);
            }
        });
        if (missingFields.length === 0) {
            return null;
        }
        return Ext.String.format('Missing fields: {0}', missingFields.join(','));
    },

    statics: {
        getUserFriendlyRuleLabel: function(ruleName){
            switch(ruleName){
                case 'ruleFn_missingFields':
                    return 'Required Fields are missing';

                case 'ruleFn_stateSynchronization':
                    return '[Feature] State is not aligned with story states';

                case 'ruleFn_featureTargetSprintMatchesRelease':
                    return '[Feature] Target Sprint not aligned with Release';

                case 'ruleFn_storiesPlannedByFeatureTargetSprint':
                    return '[Feature] child stories are planned after Feature Target Sprint';

                case 'ruleFn_featureStateShouldMatchTargetSprint':
                    return '[Feature] State not aligned with Target Sprint';

                case 'ruleFn_unscheduledIterationScheduleState':
                    return '[User Story] is In-Progress with unscheduled Iteration';

                case 'ruleFn_blockedFieldsPopulated':
                    return '[User Story] Blocked fields not populated';

                case 'ruleFn_blockedNotInProgress':
                    return '[User Story] is Blocked but not In-Progress';

                case 'ruleFn_sprintCompleteNotAccepted':
                    return '[User Story] in past Iteration not complete';
            }
            return ruleName;
        }
    }
});
Ext.define('Rally.technicalservices.Validator',{

    validationRuleObj: undefined,
    records: undefined,

    ruleViolationData: undefined,

    constructor: function(config){
        Ext.apply(this,config);
        this._validate();
    },

    _validate: function(){
        if (this.validationRuleObj && this.records){
            var validationRuleObj = this.validationRuleObj,
                ruleViolationRecords = [],
                totalRecords = 0,
                rules = validationRuleObj.getRules();

            _.each(this.records, function(r){
                totalRecords ++;
                var violations = [];
                _.each(rules, function(rule){
                    var v = validationRuleObj[rule](r);
                    if (v){
                        violations.push({rule: rule, text: v});
                    }
                });

                if (violations.length > 0){
                    ruleViolationRecords.push({
                        _ref: r.get('_ref'),
                        FormattedID: r.get('FormattedID'),
                        Name: r.get('Name'),
                        violations: violations,
                        Project: r.get('Project').Name,
                        _type: r.get('_type')
                    });
                }
            });
            this.ruleViolationData = ruleViolationRecords;
        }
    }
});
Ext.define("work-item-field-issues", {
        extend: 'Rally.app.App',
        componentCls: 'app',
        logger: new Rally.technicalservices.Logger(),

        /**
         * Configurations
         */
        allReleasesText: 'All Releases',
        portfolioItemFeature: 'PortfolioItem/Feature',
        featureFetchFields: ['FormattedID','Name','Project','Release','State','AcceptedLeafStoryCount','LeafStoryCount','PlannedStartDate','PlannedEndDate','Owner'],
        storyFetchFields: ['FormattedID','Name','Project','Iteration','Release','ScheduleState','Feature','Owner','PlanEstimate'],
        iterationFetchFields: ['Name','StartDate','EndDate','State','ObjectID'],


        typeMapping: {
            'portfolioitem/feature': 'Feature',
            'hierarchicalrequirement': 'User Story'
        },

        chartColors: [ '#2f7ed8', '#8bbc21', '#910000',
            '#492970', '#f28f43', '#145499','#77a1e5', '#c42525', '#a6c96a',
            '#7cb5ec', '#434348', '#90ed7d', '#f7a35c', '#8085e9','#aa1925',
            '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1','#1aadce',
            '#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
            '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],

        launch: function() {
            this._addReleaseSelector();
        },
        getIterationFilters: function(){
            var release = this.getReleaseRecord();

            if (release == null || release.get('Name') == this.allReleasesText){
                return [];
            }

            var filters = Rally.data.wsapi.Filter.and([{
                property: 'StartDate',
                operator: '<',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
            },{
                property: 'EndDate',
                operator: '>',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
            }]);
            return filters;
        },

        getReleaseFilters: function(){

            var release = this.getReleaseRecord();

            return [{
                property: 'Release.Name',
                value: release.get('Name')
            },{
                property: 'Release.ReleaseStartDate',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
            },{
                property: 'Release.ReleaseDate',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
            }];
        },

        onReleaseUpdated: function(cb){
            this.logger.log('onReleaseUpdated',cb.getValue());
            this.getBody().removeAll();

            this.setLoading(true);
            var promises = [
                this._fetchData(this.portfolioItemFeature, this.featureFetchFields, this.getReleaseFilters()),
                this._fetchData('HierarchicalRequirement', this.storyFetchFields, this.getReleaseFilters()),
                this._fetchData('Iteration', this.iterationFetchFields, this.getIterationFilters())
            ];

            Deft.Promise.all(promises).then({
                scope: this,
                success: function(records){
                    this.setLoading(false);
                    this.logger.log('_fetchData success', records);

                    var featureRules = Ext.create('Rally.technicalservices.FeatureValidationRules',{
                            stories: records[1],
                            iterations: records[2]
                        }),
                        featureValidator = Ext.create('Rally.technicalservices.Validator',{
                            validationRuleObj: featureRules,
                            records: records[0]
                        });

                    var storyRules = Ext.create('Rally.technicalservices.UserStoryValidationRules',{}),
                        storyValidator = Ext.create('Rally.technicalservices.Validator',{
                            validationRuleObj: storyRules,
                            records: records[1]
                        });

                    this.logger.log('featureStats',featureValidator.ruleViolationData, storyValidator.ruleViolationData);

                    this.validatorData = featureValidator.ruleViolationData.concat(storyValidator.ruleViolationData);
                    this._createSummaryHeader(this.validatorData);

                },
                failure: function(operation){
                    this.setLoading(false);
                    this.logger.log('_fetchData failure', operation);
                }
            });
        },
        _createSummaryHeader: function(validatorData){
            this.logger.log('_createSummaryHeader',validatorData);

            var ct_summary = this.getBody().add({
                xtype: 'container',
                layout: {type: 'hbox'}
            });

            var ct_chart = ct_summary.add({
                xtype: 'container',
                flex: 1,
                minHeight: 300
            });

            this._createSummaryChart(ct_chart, validatorData);

            var ct_detail_grid = this.getBody().add({
                xtype: 'container'
            });
            this._createDetailGrid(ct_detail_grid, validatorData);

        },
        _onPointSelect: function(thisApp, thisPoint){
            thisApp.logger.log('_onPointSelect', thisPoint);

           var ruleName = thisPoint.id;
           var grid = thisApp.down('#detail-grid');

            grid.getStore().clearFilter(true);

            grid.getStore().filterBy(function(rec){
                var violations = rec.get('violations'),
                    filter = false;
                if (violations){
                    _.each(violations, function(v){
                        if (v.rule == ruleName){
                            filter = true;
                        }
                    });
                }
                return filter;
            });
        },
        _onPointUnselect: function(thisApp, fromPoint){
            if (fromPoint.selected){
                thisApp.down('#detail-grid').getStore().clearFilter();
            }
        },
        _createSummaryChart: function(ct,validatorData){

            //var categories [];
            //
            //_.each(categories, function(c){
            //    series.push({
            //        name: 'xxx',
            //        data: [],
            //        stack: type,
            //        point: {
            //            events: {
            //                select: function () {
            //                    me._onPointSelect(me, this);
            //                },
            //                unselect: function () {
            //                    me._onPointUnselect(me, this);
            //                }
            //            }
            //        }
            //    });
            //});
            //
            //var grid = this.down('#detail-grid');
            //
            //var me = this;
            //ct.add({
            //    xtype: 'rallychart',
            //    itemId: 'summary-chart',
            //    loadMask: false,
            //    chartData: {
            //        series: series
            //    },
            //    chartConfig: {
            //        chart: {
            //            type: 'column'
            //        },
            //        title: 'Work Item Field Issues',
            //        legend: {
            //            align: 'center',
            //            verticalAlign: 'bottom'
            //        },
            //        xAxis: {
            //            categories: categories
            //        },
            //        yAxis: {
            //            title: 'Project'
            //        },
            //        plotOptions: {
            //            column: {
            //               stacking: 'normal'
            //                }
            //            }
            //        }
            //    });
        },
        _createDetailGrid: function(ct, violationData){

            ct.removeAll();

            var store = Ext.create('Rally.data.custom.Store',{
                data: violationData,
                pageSize: violationData.length,
                //groupField: 'Project',
                //groupDir: 'ASC',
                remoteSort: false,
                //getGroupString: function(record) {
                //    return record.get('Project');
                //}
            });

            ct.add({
                xtype:'rallygrid',
                store: store,
                itemId: 'detail-grid',
                columnCfgs: this._getColumnCfgs(),
                showPagingToolbar: false
                //features: [{
                //    ftype: 'groupingsummary',
                //    groupHeaderTpl: '{name} ({rows.length})',
                //    startCollapsed: true
                //}]
            });
        },
        _getColumnCfgs: function(){
            return [{
                dataIndex: 'FormattedID',
                text: 'FormattedID',
                renderer: this._artifactRenderer
            },{
                dataIndex: 'Project',
                text: 'Project'
            },{
                dataIndex: 'violations',
                text:'Issues',
                renderer: this._validatorRenderer,
                flex: 1
            }];
        },
        _artifactRenderer: function(v,m,r){
            return Rally.nav.DetailLink.getLink({
                record: r,
                text: v
            });
            return v;
        },
        _validatorRenderer: function(v,m,r){
            var issues = '';
            if (v && v.length > 0){
                _.each(v, function(va){
                    issues += va.text + '<br/>';
                });
            }
            return issues;
        },
        _fetchData: function(modelType, fetchFields, filters){

            var deferred = Ext.create('Deft.Deferred'),
                store = Ext.create('Rally.data.wsapi.Store',{
                    model: modelType,
                    limit: 'Infinity',
                    fetch: fetchFields,
                    filters: filters
                });

            store.load({
                scope: this,
                callback: function(records, operation, success){
                    if (success){
                        deferred.resolve(records);
                    } else {
                        deferred.reject(operation);
                    }
                }
            });
            return deferred;
        },

        _addReleaseSelector: function(){
            this.logger.log('_addReleaseSelector');
            var cb = this.getHeader().add({
                xtype: 'rallyreleasecombobox',
                itemId: 'cb-release',
                fieldLabel: 'Release',
                labelAlign: 'right',
                allowNoEntry: false,
                width: '300'
            });
            cb.on('change', this.onReleaseUpdated,this);
        },


        getReleaseRecord: function(){
            if (this.down('#cb-release')){
                return this.down('#cb-release').getRecord();
            }
            return null;
        },

        getHeader: function(){
            this.logger.log('getHeader');

            if (this.down('#ct-header')){
                return this.down('#ct-header');
            }

            return this.add({
                xtype: 'container',
                itemId: 'ct-header',
                layout: {type: 'hbox'}
            });
        },

        getBody: function(){
            this.logger.log('getBody');

            if (this.down('#ct-body')){
                return this.down('#ct-body');
            }
            return this.add({
                xtype: 'container',
                itemId: 'ct-body'
            });
        }
    });

Ext.define('Rally.technicalservices.FeatureValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',

    requiredFields: undefined,
    iterations: [],
    stories: [],

    constructor: function(config){
        Ext.apply(this, config);
        this.requiredFields = ['Owner','PlannedEndDate','PlannedStartDate','State'];

    },
    //ruleFn_stateSynchronization: function(r) {
    //    /**
    //     * State == Done,
    //     * then all user stories should be accepted
    //     * AND
    //     * if All user stories == Accepted,
    //     * State should be Done
    //     */
    //
    //    var featureDone = r.get('State') ? r.get('State').Name === 'Done' : false ,
    //        storiesAccepted = r.get('AcceptedLeafStoryCount') === r.get('LeafStoryCount');
    //
    //    if (featureDone === storiesAccepted){
    //        return null;
    //    }
    //    if (featureDone){
    //        return Ext.String.format('Feature is Done but not all stories are accepted ({0} of {1} accepted)', r.get('AcceptedLeafStoryCount'), r.get('LeafStoryCount'));
    //    }
    //    return Ext.String.format('Feature state ({0}) should be Done because all stories are accepted.', r.get('State').Name);
    //},
    ruleFn_featureRule2: function(r){
        /**
         * FTS == R4.xxx,
         * and R4.xxx == iteration (R4.xxx),
         * and iteration (R4.xxx) == done, then
         * FTS.State should be Done
         */
        return null;
    }
});

Ext.define('Rally.technicalservices.UserStoryValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',
    //ruleFnPrefix: 'ruleFn_',
    requiredFields: undefined, //

    constructor: function(config){
        Ext.apply(this, config);
        this.requiredFields = ['Owner','Feature','PlanEstimate'];
    },
    ruleFn_unscheduledIterationScheduleState: function(r){
        /**
         * If Iteration = unscheduled and state In-Progress raise flag
         */
        if (!r.get('Iteration') && r.get('ScheduleState') != 'Defined'){
            return Ext.String.format('{0} is an invalid state for an unscheduled Iteration', r.get('ScheduleState'));
        }
        return null;
    },
    ruleFn_blockedNotInProgress: function(r){
        /**
         * Story is blocked, schedulestate must be In-Progress
         */
        if (r.get('Blocked')){
            if (r.get('ScheduleState') != 'In-Progress'){
                return Ext.String.format('Invalid State ({0}) for blocked story', r.get('ScheduleState'));
            }
        }
        return null;
    }
});


            
               Rally.launchApp('work-item-field-issues', {
                   name: 'Work Item Field Issues'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>