<!DOCTYPE html>
<html>
<head>
    <title>progress-by-project</title>

    <script type="text/javascript" src="/apps/2.0rc2/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/async/1.22/async.min.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
Ext.define("RallyFunctions", function() {

    var self;

    return {
        config : {
            ctx : {}
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            return this;
        },

        _wsapiQuery : function( config , callback ) {

            var storeConfig = {
                autoLoad : true,
                limit : "Infinity",
                model : config.model,
                fetch : config.fetch,
                filters : config.filters,
                listeners : {
                    scope : this,
                    load : function(store, data) {
                        callback(null,data);
                    }
                }
            };
            if (!_.isUndefined(config.context)) {
                storeConfig.context = config.context;
            }         
            Ext.create('Rally.data.WsapiDataStore', storeConfig);
        },

        // create a filter based on a combination of release and/or iteration
        createFilter : function( releaseName, iterationName ) { 
            var filter = null;

            if (!_.isNull(releaseName)) {
                filter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Release.Name',
                    operator: '=',
                    value: releaseName
                });
            }

            if (!_.isNull(iterationName)) {
                var ifilter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Iteration.Name',
                    operator: '=',
                    value: iterationName
                });

                filter = _.isNull(filter) ? ifilter : filter.and(ifilter);              
            }
            return filter;
        }
       
    };
   
});
                /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
Ext.define("ProjectStories", function() {

    var self;

    return {
        config : {
            ctx : {},
            filter : null
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            return this;
        },

        readProjectStories : function(callback) {
            var fns = [
                self.readStates.bind(self),
                self.readProjects.bind(self),
                self.getReportProjects.bind(self),
                self.readStories.bind(self)
            ];

            async.waterfall( fns , function(err,result) {
                console.log("result",result);
                callback( null, result, self.reportProjects, self.scheduleStates );
            });
        },

        readStates : function(callback) {
            var that = this;
            Rally.data.ModelFactory.getModel({
                type: 'UserStory',
                success: function(model) {
                    model.getField('ScheduleState').getAllowedValueStore().load({
                        callback: function(records, operation, success) {
                            self.scheduleStates = _.map(records,function(r){ return r.get("StringValue");});
                            callback(null);
                        }
                    });
                }
            });
        },

        readProjects : function(callback) {
            var that = this;
            var config = { model : "Project", fetch : true, filters : [] };
            self._wsapiQuery(config,callback);
        },    

        // child projects are what we graph
        getReportProjects : function(projects,callback) {

           self.projects = projects;

            // filter to projects which are child of the current context project
            self.reportProjects = _.filter(projects, function(project) {
                return self._isChildOf( project, self.ctx.getProject() );
            });

            // if no children add self
            if (self.reportProjects.length ===0) {
                self.reportProjects.push(_.find(self.projects,function(project) {
                    return project.get("ObjectID") === self.ctx.getProject().ObjectID;
                }));
            }

            callback(null);
        },

        readStories : function(callback) {

            var configs = _.map(self.reportProjects,function(project) {
                return {
                    model : "HierarchicalRequirement",
                    filters : [self.filter],
                    fetch : ["ObjectID","ScheduleState","PlanEstimate","Project"],
                    context : {
                        project: project.get("_ref"),
                        projectScopeUp: false,
                        projectScopeDown: true
                    }
                };
            });

            // read stories for each reporting project
            async.map(configs,self._wsapiQuery,function(error,results) {
                callback(null,results);
            });
        },
         

        _wsapiQuery : function( config , callback ) {

            var storeConfig = {
                autoLoad : true,
                limit : "Infinity",
                model : config.model,
                fetch : config.fetch,
                filters : config.filters,
                listeners : {
                    scope : this,
                    load : function(store, data) {
                        callback(null,data);
                    }
                }
            };
            if (!_.isUndefined(config.context)) {
                storeConfig.context = config.context;
            }         
            Ext.create('Rally.data.WsapiDataStore', storeConfig);
        },

        _isChildOf : function( child, parent ) {
            var childParentRef = !_.isNull(child.get("Parent")) ? child.get("Parent")._ref : "null";
            return parent._ref.indexOf( childParentRef ) > -1;
        }
        
    };
   
});
                Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    launch: function() {
        var that = this;
        var release = null;
        var iteration = "Iteration 1"; // this.getTimeboxScope();

        that.rallyFunctions = Ext.create("RallyFunctions");

        var tbs = that.getTimeboxScope();
        if (!_.isNull(tbs)) {
            release = tbs.type === "release" ? tbs.name : null;
            iteration = tbs.type === "iteration" ? tbs.name : null;
        }
        that.run(release,iteration);
    },

    run : function(releaseName,iterationName) {

        var that = this;

        var pr = Ext.create( "ProjectStories", {
            ctx : that.getContext(),
            filter : that.rallyFunctions.createFilter(releaseName,iterationName)
        });

        pr.readProjectStories(function(error, stories, projects, states) {
            that.prepareChartData( stories, projects, state, function(error, categories, series) {
              that.createChart( categories, series );
            });
        });

    },

    getTimeboxScope : function() {

        var timeboxScope = this.getContext().getTimeboxScope();
        if (timeboxScope) {
            return { type : timeboxScope.getType(), name : timeboxScope.getRecord().get("Name") };
        }
        return null;
    },

    onTimeboxScopeChange: function(newTimeboxScope) {

        this.callParent(arguments);
        if ((newTimeboxScope) && (newTimeboxScope.getType() === 'iteration')) {
            this.run(null,newTimeboxScope.getRecord().get("Name"));
        } else {
            if ((newTimeboxScope) && (newTimeboxScope.getType() === 'release')) {
                this.run(newTimeboxScope.getRecord().get("Name"),null);
            }
        }
    },

    prepareChartData : function(stories, projects, states, callback) {

        var that = this;

        var projectKeys = _.map(projects,function(project) { return project.get("Name"); });

        var pointsValue = function(value) {
            return !_.isUndefined(value) && !_.isNull(value) ? value : 0;
        };

        // totals points for a set of work items based on if they are in a set of states
        var summarize = function( workItems, states ) {

            // calc total points
            var total = _.reduce(workItems, function(memo,workItem) {
                    return memo + pointsValue(workItem.get("PlanEstimate"));
            },0);

            // totals points for a set of work items based on if they are in a set of states
            var stateTotal = _.reduce(  workItems, function(memo,workItem) {
                return memo + ( _.indexOf(states,workItem.get("ScheduleState")) > -1 ? 
                            pointsValue(workItem.get("PlanEstimate")) : 0);
            },0);

            var p = ( total > 0 ? ((stateTotal/total)*100) : 0);
            return Math.round(p);
        };

        var summary = that.createSummaryRecord();

        var seriesData = _.map( _.keys(summary), function( summaryKey ) {
            return {
                name : summaryKey,
                data : _.map( projectKeys, function( projectKey ) {
                    return summarize( groupedWorkItems[projectKey], summary[summaryKey]);
                })
            };
        });

        callback(null, projectKeys, seriesData );

    },

    createChart : function(categories,seriesData,callback) {

        var that = this;

        if (!_.isUndefined(that.chart)) {
            that.remove(that.chart);
        }

        that.chart = Ext.create('Rally.technicalservices.progressChart', {
            itemId: 'rally-chart',
            chartData: { series : seriesData, categories : categories },
            title: 'Progress By Project'
        });

        that.add(that.chart);

        var chart = this.down("#rally-chart");
        var p = Ext.get(chart.id);
        elems = p.query("div.x-mask");
        _.each(elems, function(e) { e.remove(); });
        var elems = p.query("div.x-mask-msg");
        _.each(elems, function(e) { e.remove(); });

    },

    // utilities below here ... 
    createSummaryRecord : function() { 

        var that = this;
      
        var summary = {
            "Backlog" : ["Defined"],
            "In-Progress" : ["In-Progress"],
            "Completed/Accepted" : ["Completed","Accepted"]
        };

        // add initial and last states if necessary
        var first = _.first(that.scheduleStates);
        var last = _.last(that.scheduleStates);
        if (_.indexOf(summary[_.first(_.keys(summary))],first)===-1)
            summary[_.first(_.keys(summary))].push(_.first(that.scheduleStates));
        if (_.indexOf(summary[_.last(_.keys(summary))],last)===-1)
            summary[_.last(_.keys(summary))].push(_.last(that.scheduleStates));

        console.log("summary",summary);
        return summary;
    }

});

                Ext.define('Rally.technicalservices.progressChart',{
    extend: 'Rally.ui.chart.Chart',
    alias: 'widget.progresschart',

    itemId: 'rally-chart',
    chartData: {},
    loadMask: false,
    chartColors : [],
    chartConfig: {
        colors : ["#E0E0E0","#00a9e0","#8dc63f"],
        chart: {
            type: 'bar'
        },
        title: {
            text: 'Progress by Project'
        },
        xAxis: {
            tickInterval: 1,
            title: {
                text: '%'
            }
        },
        yAxis: [
            {
                min: 0,
                max: 100,
                title: {
                    text: '% of Scheduled Stories by State'
                }
            }
        ],
        plotOptions: {
            series: {
                dataLabels: {
                    enabled: true,
                    align: 'center',
                    formatter : function() {
                        return Math.round(this.percentage) + " %";
                    },
                    color: '#FFFFFF'
                },
                stacking: 'normal'
            }        
        }
    },
    constructor: function (config) {
        this.callParent(arguments);
        if (config.title){
            this.chartConfig.title = config.title;
        }
    }
});

            Rally.launchApp('CustomApp', {
                name:"progress-by-project",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
